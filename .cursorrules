# Medieval Strategy Game - Cursor Rules

## Project Overview
This is a Next.js medieval strategy game built with TypeScript, Prisma, and Tailwind CSS. It features real-time gameplay, admin dashboard, and comprehensive game mechanics.

## Code Style & Structure

### File Organization
- `/app` - Next.js 13+ app router structure
- `/components` - React components organized by feature
- `/lib` - Business logic and utilities
- `/docs` - Documentation for all features
- `/prisma` - Database schema and migrations

### Naming Conventions
- **Files**: kebab-case for components and pages, camelCase for utilities
- **Components**: PascalCase, descriptive names
- **Functions**: camelCase, verb-based names
- **Constants**: UPPER_SNAKE_CASE
- **Types**: PascalCase with descriptive names

### Code Patterns

#### API Routes
```typescript
// Good: Clear structure with validation
export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    // Validate input
    const validatedData = validateInput(body)
    // Process data
    const result = await processData(validatedData)
    return NextResponse.json({ success: true, data: result })
  } catch (error) {
    return NextResponse.json({ error: "Something went wrong" }, { status: 500 })
  }
}
```

#### React Components
```typescript
// Good: Clean, functional components with proper typing
interface Props {
  data: SomeType
  onAction: (id: string) => void
}

export function ComponentName({ data, onAction }: Props) {
  return (
    <div>
      {/* Component content */}
    </div>
  )
}
```

#### Database Operations
```typescript
// Good: Use transactions for related operations
await prisma.$transaction(async (tx) => {
  await tx.table1.update({ where: { id }, data: updateData1 })
  await tx.table2.update({ where: { id }, data: updateData2 })
})
```

## Development Guidelines

### Error Handling
- Always use try/catch blocks in API routes
- Return consistent error responses
- Log errors appropriately
- Validate user input on both client and server

### State Management
- Use React hooks for component state
- Consider context for shared state
- Keep state as local as possible

### Performance
- Use React.memo for expensive components
- Implement proper loading states
- Optimize database queries with proper indexing

## Game-Specific Rules

### Admin Features
- All admin actions must be logged to AuditLog table
- Validate all inputs server-side
- Use confirmation dialogs for destructive actions
- Provide clear success/error feedback
- JWT authentication required for all admin endpoints
- Role-based permissions (MODERATOR, ADMIN, SUPERADMIN)
- Bulk operations for efficient player management
- Real-time action tracking and error monitoring

### API Design
- Use RESTful conventions
- Return consistent response format: `{ success: boolean, data?: any, error?: string }`
- Include proper HTTP status codes
- Document all endpoints in `/docs/admin/`
- Admin endpoints require Bearer token authentication
- Comprehensive error handling and validation

### Database Schema
- Use Prisma for type safety
- Add proper indexes for performance
- Use transactions for complex operations
- Include migration files for schema changes
- Audit logging for all administrative actions
- Separate Admin model for role management
- AdminNotification model for system alerts
- TroopBalance model for persistent unit configuration
- WebSocket server for real-time admin statistics
- Analytics API for comprehensive player insights
- Maintenance model for system maintenance tracking
- AdminMessage model for admin-player communication
- Advanced search API with multi-criteria filtering

## Documentation Requirements

### Feature Documentation
- Every feature must have documentation in `/docs/features/`
- Include setup, usage, and API examples
- Update docs when features change

### API Documentation
- Document all endpoints in `/docs/api/`
- Include request/response examples
- Specify required parameters and validation rules

### Changelog
- Maintain root `CHANGELOG.md` (not in `docs/`).
- Update with every significant change using the format below.
- Prefer semantic, conventional entries (feat, fix, chore, docs, refactor, perf, test).

#### Changelog Entry Template
```
## Unreleased
- type(scope): short summary — PR/Context if relevant
  - files: path/one.ts, path/two.ts
  - details: optional multi-line description
```

#### Automation
- When the agent (Cursor/Codex) adds/modifies files, append an entry to root `CHANGELOG.md`.
- You may run `npm run changelog:update -- --type <type> --scope <scope> --summary "..." --description "..."`.
- If arguments are omitted, the script will infer changed files via `git status` and only require `--type` and `--summary`.

## Testing & Quality

### Code Quality
- Run TypeScript checks
- Fix all linting errors
- Write clear, readable code
- Add comments for complex logic

### Database Migrations
- Always test migrations on development database
- Include rollback plans for complex changes
- Update schema documentation

## Security

### Input Validation
- Validate all user inputs
- Sanitize database queries
- Use parameterized queries
- Implement rate limiting for sensitive endpoints

### Authentication
- Secure admin endpoints
- Implement proper session management
- Log security events

## Git Workflow

### Commits
- Write clear, descriptive commit messages
- Commit related changes together
- Use conventional commit format when possible

### Branching
- Use feature branches for new work
- Merge to main only after review
- Keep branches focused and short-lived

## Project Rules (from AGENTS.md)

- Keep controllers in `app/` thin; move combat, economy, and auth logic into `lib/`.
- Components live under `components/` split into `ui`, `game`, `admin` and re-export via `index.ts`.
- Shared hooks in `hooks/`. Reusable tooling in `scripts/`. Building blueprints in `lib/config` and `lib/game-services`.
- Prisma schema/migrations/seeds live in `prisma/`. Mirror gameplay expectations in `docs/` when schema/building rules change.
- TypeScript, 2-space indentation, trailing commas, prefer named exports.
- Components: PascalCase. Utilities: camelCase. Constants: UPPER_SNAKE_CASE. Files: kebab-case.
- Default to server components. Only browser hooks go in `hooks/`. Never import Prisma models client-side.
- Use Tailwind + shadcn/ui primitives; preserve inline comments for endgame/combat logic.

## Commands

- `npm run dev` — start Next.js at http://localhost:3000
- `npm run build` / `npm start` — production bundle
- `npm run lint` — ESLint + Next rules
- `npm run prisma:seed` or `npx tsx scripts/seed-fake-tribes.ts` — reseed worlds
- `node test-combat-system.js` (or any `test-*.js`) — smoke tests after seeding
- `npm run changelog:update -- --type <type> --scope <scope> --summary "..."` — append to root `CHANGELOG.md`

## File Structure Standards

### Components
```
components/
  ui/           # Reusable UI components
  game/         # Game-specific components
  admin/        # Admin dashboard components
```

### API Routes
```
app/api/
  admin/        # Admin-only endpoints
  game/         # Game logic endpoints
  auth/         # Authentication endpoints
```

### Documentation
```
docs/
  features/     # Feature documentation
  api/          # API documentation
  admin/        # Admin feature docs
  development/  # Development guides
```

## Performance Considerations

- Optimize images and assets
- Use proper caching strategies
- Minimize bundle size
- Profile performance regularly

## Accessibility

- Include proper ARIA labels
- Ensure keyboard navigation
- Maintain proper color contrast
- Test with screen readers

Remember: Clean code is readable, maintainable, and scalable. Always consider the impact of your changes on the overall system.
